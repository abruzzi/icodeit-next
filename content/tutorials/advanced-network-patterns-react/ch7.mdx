---
order: 7
title: "Server Side Rendering"
description: "Chapter 6 delves into advanced prefetching techniques in React applications, using SWR for efficient data fetching. It highlights how to enhance application responsiveness and user experience through strategic data loading and parallel network requests."
date: 2024-01-21T17:00:12+11:00
tutorialId: "advanced-network-patterns-react"
next: "ch8"
highlights:
  - Implementing SWR for optimized data fetching
  - Strategic use of preload for earlier data loading
  - Balancing JavaScript bundle loading with data fetching for enhanced interactivity
leading: "As we conclude this tutorial, we reflect on the key lessons learned and set the stage for exploring server-side technology and its impact on application performance."
summary: "This final chapter wraps up our exploration of network patterns in React. We've covered parallel requests, code splitting, and prefetching to improve performance. Up next, we'll explore server-side technologies to further enhance application performance."
draft: true
---

The idea is that we can send request from backend and assembling final HTML all together, so client side can save some time on request network again (especially when each request take some overhead time on establishing network connection, etc.)

<InfoBox>
  Server-Side Rendering (SSR) is a web development technique where the server generates the complete HTML of a webpage in response to a user's request. This process takes place each time a user accesses a URL or refreshes their browser. The server executes the necessary JavaScript code, renders all the dynamic content, and then sends this fully prepared HTML to the user's browser. Although this method involves some processing time on the server, it allows the browser to display a fully rendered page more quickly compared to waiting for client-side JavaScript to render content. SSR enhances user experience, particularly for the initial page load, and improves the website's search engine optimization by ensuring all content is immediately accessible.
</InfoBox>

From now on, I’m going to use Next.js for SSR, although there are many other alternatives like Remix or so (you can even build your own SSR solution, but that would out of scope of this article).

If you don’t familiar with Next.js, it’s recommended to walk through at least the dashboard tutorial it provides. You might want to follow the tutorial and have a play with it, and come back later.

<InfoBox>
  Next.js is an open-source web development framework built on top of Node.js, enabling developers to build server-rendered React applications with ease. It was created by Vercel (formerly Zeit) and is designed to simplify the process of building universal, web applications with React.

  The primary goal of Next.js is to provide a straightforward and efficient way to build performant, scalable, and user-friendly web applications. It focuses on enhancing the developer experience with features like automatic code splitting, server-side rendering (SSR), static site generation (SSG), and built-in CSS support. Next.js aims to streamline the process of building complex React applications, making them more accessible to a broader range of developers.
</InfoBox>

Let’s define a `getUserBasicInfo` in backend a dynamic routing in Next.js `app/user/[id]/page.tsx`

```tsx
async function getUserBasicInfo(id: string) {
  const [user, friends] = await Promise.all([
    get<User>(`/users/${id}`),
    get<User[]>(`/users/${id}/friends`),
  ]);

  return { user, friends };
}
```

<InfoBox>
  In version 13, Next.js introduced a new App Router built on **React Server Components**, which supports shared layouts, nested routing, loading states, error handling, and more.

  The system is based on the file system, meaning that the routes are determined by the file structure in the "app" directory of your Next.js project. And there are some convention to following,

  Read more on [Routing Fundamentals](https://nextjs.org/docs/app/building-your-application/routing) and
  [Pages and Layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts).
</InfoBox>

And then in the `Page` component, we can call this function to get all data and then send to frontend:

```tsx {2}
export default async function Page({ params }: PageProps) {
  const { user, friends } = await getUserBasicInfo(params.id);
  return (<Profile user={user} friends={friends} />);
}
```

The PageProps is defined:

```tsx
interface PageProps {
  params: {
    id: string;
  };
}
```

In Next.js, `app/user/[id]/page.tsx` represents a dynamic route within the `app` directory. The `[id]` part indicates a variable segment in the URL, which can change based on the user ID. For example, accessing `/user/123` would render the `page.tsx` component for the user with ID 123. This file structure is used for creating pages that change content based on the URL parameter, like displaying different user profiles.

While the `Profile` is defined as a simple presentational component, note how we removed the `loading` and all the status:

```tsx
const Profile = ({ user, friends }: { user: User; friends: User[] }) => {
  return (
    <>
      <About user={user} />
      <Friends users={friends} />
      <Feeds category={user.interests[0]} />
    </>
  );
};
```

We didn’t change the behaviour of `Feeds` though, as that’s some less critical information in such context (and also I would like to show the comparison here too), so we use it as a `Client` component - meaning it behaves as a normal traditional React component:

```tsx title="components/feeds.tsx" {1, 9-22}
'use client';

import { useEffect, useState } from "react";

const Feeds = ({ category }: { category: string }) => {
  const [loading, setLoading] = useState<boolean>(false);
  const [feeds, setFeeds] = useState<Feed[]>([]);

  useEffect(() => {
    const fetchFeeds = async () => {
      setLoading(true);
      const response = await fetch(
        `http://localhost:1573/articles/${category}`
      );
      const data = await response.json();

      setLoading(false);
      setFeeds(data);
    };

    fetchFeeds();
  }, [category]);

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h2>Your Feeds</h2>
      <div>
        {feeds.map((feed) => (
          <>
            <h3>{feed.title}</h3>
            <p>{feed.description}</p>
          </>
        ))}
      </div>
    </div>
  );
};

export { Feeds };
```

Note how we use `use client` directive to mark it as a client component.

And now when we load the page, initially it is a bit slow, and then we see `About` and `Friends` all together, and immediately we see `loading` for the feeds, and finally when feeds returns we can see all the content.

![Feeds are in loading while About and Friends are ready](/tutorials/advanced-network-patterns-react/ch7/feeds-is-loading.png)

You might be wondering what is the point to move these request from frontend to backend. There are a few advantages:

- Normally the server side is closer to where the data is stored than frontend, so it’s normally faster to get the data
- It’s easier to caching (and control) these data in server side
- more security in backend
- server machine are more powerful
- It’s more secure (like, use of API key or token in backend) and frontend is transparent of such setups

And if we visualise this type of code, it looks like:

![Server Side Rendering](/tutorials/advanced-network-patterns-react/ch7/server-side-rendering.png)

The initial load might take a bit more time, but after that the application is responsible and don’t have to load any data, that means better user experience. The generated data can be cached also in different levels, so the next time when we request the same data we can save some time.
