---
title: "From Commit to Deployment"
description: "Let's explore A Journey Through Software Production from commit to deployment."
date: 2023-07-01T17:46:12+11:00
cover: "/products/courses/from-commit-to-deployment.png"
level: "beginner"
tutorialId: "from-commit-to-deployment"
---

Software development is a complex process. A seemingly simple application often hides a multitude of factors that can lead to its failure. Unstable networks, erroneous connection strings, inconsistent data formats, forgotten memory cleanups, unreleased log spaces, and so on, all contribute to uncertainties that force developers to tread carefully. In a typical software project, especially one with some scale that involves multiple teams, we see a process like this happening daily: modify code, transfer to testing, reject and revise, re-test, integrate, jointly debug, discover new issues, reject and revise again, re-test again, and so forth.

Software development shouldn't be like this, and it **can** be different. The crux of the matter lies in gaining confidence in software behavior before release, and in the efficiency of rolling back to a previous working version when a problem is discovered. In other words, if we are 90% confident in new changes at the time of release, we will release it. Additionally, if an issue arises online, we can switch back to a previous version in a very short time. If we can achieve these two points, we probably don't need to worry about things like transferring to testing, joint debugging, etc., after all, we can always fall back to the previous version.

However, achieving this is not easy. We need to build many protective mechanisms and infrastructure in advance. Each code change triggers rigorous automated tests, each file modification adheres to predefined rules, each merge triggers all automated regression tests, acceptance tests, and end-to-end tests, and eventually forms a deployable software package (sometimes an image file). That is, we eliminate error-prone issues with automation from the beginning, and if they can't be eliminated, we can promptly remediate.

This is the essence of this book: through writing automated build scripts and implementing continuous delivery practices, we can achieve a more efficient and developer-friendly delivery method. The main purpose of this book is to teach you through a real example how to define build scripts, how to use these scripts in local and continuous integration environments, and how to perform common development tasks such as translation (translation+compiling), static checking, packaging, automated testing, automated deployment, etc., to achieve continuous delivery, improve efficiency, and ensure product quality.
